// Generated by CoffeeScript 1.7.1
(function() {
  var Network, PREFIX, debug, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  PREFIX = "";

  debug = true;

  Network = function() {
    var allData, anyMatchInArray, collide, color, container, curLinksData, curNodesData, drag, dragended, dragged, dragstarted, filter, filterLinks, filterNodes, force, forceTick, height, hideDetails, link, linkPath, linkWeight, linkedByIndex, linksG, mapNodes, neighboring, network, node, nodesG, setSize, setupData, showDetails, svgH, svgW, tip, update, updateLinks, updateNodes, vis, width, xScale, yScale, zoom, zoomToNode, zoomed;
    width = 700;
    height = 600;
    svgW = width;
    svgH = height;
    vis = null;
    container = null;
    nodesG = null;
    linksG = null;
    node = null;
    link = null;
    filter = [];
    allData = [];
    curLinksData = [];
    curNodesData = [];
    linkedByIndex = {};
    linkWeight = {};
    color = d3.scale.ordinal().range(["#74c476", "#fd8d3c", "#207ec2", "#9467bd"]);
    tip = d3.tip().attr('class', 'd3-tip').html(function(d) {
      return d.name;
    }).direction('n').offset(function(d) {
      return [-(d.radius / 2 + 3), 0];
    });
    force = d3.layout.force().charge(-250).linkDistance(120).size([width, height]);
    xScale = d3.scale.linear().domain([0, width]).range([0, width]);
    yScale = d3.scale.linear().domain([0, height]).range([0, height]);
    zoomed = function() {
      if (debug) {
        console.log("zoomed! translate:", d3.event.translate, "scale:", d3.event.scale);
      }
      return forceTick();
    };
    dragstarted = function(d) {
      d3.event.sourceEvent.stopPropagation();
      return d3.select(this).classed("dragging", true);
    };
    dragged = function(d) {
      var mouse;
      if (debug) {
        console.log("DRAG");
      }
      mouse = d3.mouse(vis.node());
      d.x = xScale.invert(mouse[0]);
      d.y = yScale.invert(mouse[1]);
      if (debug) {
        return console.log("drag", mouse[0], mouse[1], "scaled:", xScale.invert(mouse[0]), yScale.invert(mouse[1]));
      }
    };
    dragended = function(d) {
      return d3.select(this).classed("dragging", false);
    };
    zoom = d3.behavior.zoom().x(xScale).y(yScale).translate([0, 0]).scale(1).scaleExtent([1, 10]).on("zoom", zoomed);
    drag = force.drag().origin(function(d) {
      return d;
    }).on("dragstart", dragstarted).on("drag", dragged).on("dragend", dragended);
    network = function(selection, graph) {
      var defs;
      vis = d3.select(selection).append("svg").attr("width", width).attr("height", height).on('click', hideDetails);
      allData = setupData(graph);
      container = vis.append("g");
      linksG = container.append("g").attr("id", "links");
      nodesG = container.append("g").attr("id", "nodes");
      defs = vis.append("defs");
      defs.selectAll("marker").data(["arrowhead", "arrowhead-background", "arrowhead-highlight"]).enter().append("marker").attr("id", function(d) {
        return d;
      }).attr("viewBox", "0 -5 10 10").attr("refX", 11).attr("refY", 0).attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5 L0,-5").attr("class", function(d) {
        return d;
      });
      vis.call(tip);
      force.on("tick", forceTick);
      update();
      return vis.call(zoom).call(zoom.event);
    };
    update = function() {
      if (filter.length > 0) {
        curNodesData = filterNodes(allData.nodes);
        curLinksData = filterLinks(allData.links, curNodesData);
      } else {
        curNodesData = allData.nodes;
        curLinksData = allData.links;
      }
      force.nodes(curNodesData);
      force.links(curLinksData);
      updateNodes();
      updateLinks();
      force.start();
      return setSize();
    };
    forceTick = function() {
      link.attr("d", function(d) {
        return linkPath(d);
      });
      node.attr("cx", function(d) {
        return xScale(d.x);
      }).attr("cy", function(d) {
        return yScale(d.y);
      });
      return node.each(collide(0.5));
    };
    updateNodes = function() {
      node = nodesG.selectAll("circle.node").data(curNodesData, function(d) {
        return d.id;
      });
      node.enter().append("circle").attr("class", "node").attr("cx", function(d) {
        return xScale(d.x);
      }).attr("cy", function(d) {
        return yScale(d.y);
      }).attr("r", function(d) {
        return d.radius;
      }).style("fill", function(d) {
        return color(d.category[0]);
      }).call(drag).on('mouseover', tip.show).on('mouseout', tip.hide).on('click', showDetails);
      return node.exit().remove();
    };
    updateLinks = function() {
      link = linksG.selectAll(".link").data(curLinksData, function(d) {
        return "" + d.source.id + "_" + d.target.id;
      });
      link.enter().append("path").attr("class", "link").attr("d", function(d) {
        return linkPath(d);
      });
      return link.exit().remove();
    };
    linkPath = function(d) {
      var dr, dsx, dsy, dtx, dty, dx, dy, gamma, tx, ty;
      dsx = xScale(d.source.x);
      dsy = yScale(d.source.y);
      dtx = xScale(d.target.x);
      dty = yScale(d.target.y);
      dx = dtx - dsx;
      dy = dty - dsy;
      dr = Math.sqrt(dx * dx + dy * dy);
      gamma = Math.atan2(dy, dx);
      tx = dtx - (Math.cos(gamma) * d.target.radius);
      ty = dty - (Math.sin(gamma) * d.target.radius);
      return "M" + dsx + "," + dsy + " A" + dr + "," + dr + " 0 0,0 " + tx + "," + ty;
    };
    filterNodes = function(allNodes) {
      var filteredNodes;
      filteredNodes = allNodes.filter(function(n) {
        return anyMatchInArray(n.category, filter);
      });
      return filteredNodes;
    };
    filterLinks = function(allLinks, curNodes) {
      curNodes = mapNodes(curNodes);
      return allLinks.filter(function(l) {
        return curNodes.get(l.source.id) && curNodes.get(l.target.id);
      });
    };
    anyMatchInArray = function(target, toMatch) {
      var cur, found, i, targetMap, _i, _len;
      found = false;
      targetMap = {};
      for (_i = 0, _len = target.length; _i < _len; _i++) {
        cur = target[_i];
        targetMap[cur] = true;
      }
      i = 0;
      while ((i < toMatch.length) && !found) {
        cur = toMatch[i];
        found = !!targetMap[cur];
        i++;
      }
      return found;
    };
    network.setFilter = function(newFilter) {
      filter = newFilter;
      return update();
    };
    setupData = function(data) {
      var circleRadius, degreeExtent, nodesMap;
      degreeExtent = d3.extent(data.nodes, function(d) {
        return d.degree;
      });
      circleRadius = d3.scale.sqrt().range([9, 17]).domain(degreeExtent);
      data.nodes.forEach(function(n) {
        var randomnumber;
        if (n.id === 5) {
          n.x = width / 2;
          n.y = height / 2;
          n.fixed = true;
        } else {
          n.x = randomnumber = Math.floor(Math.random() * width);
          n.y = randomnumber = Math.floor(Math.random() * height);
          n.fixed = false;
        }
        return n.radius = circleRadius(n.degree);
      });
      nodesMap = mapNodes(data.nodes);
      data.links.forEach(function(l) {
        l.source = nodesMap.get(l.source);
        l.target = nodesMap.get(l.target);
        linkedByIndex["" + l.source.id + "," + l.target.id] = 1;
        return linkWeight["" + l.source.id + "," + l.target.id] = l.weight;
      });
      return data;
    };
    mapNodes = function(nodes) {
      var nodesMap;
      nodesMap = d3.map();
      nodes.forEach(function(n) {
        return nodesMap.set(n.id, n);
      });
      return nodesMap;
    };
    network.updateSearch = function(searchTerm) {
      var meta, searchRegEx;
      if (searchTerm) {
        searchRegEx = new RegExp(searchTerm.toLowerCase());
        meta = "<h2>Suchergebnisse</h2><div class=\"flex\">";
        node.each(function(d) {
          var element, match;
          element = d3.select(this);
          match = d.name.toLowerCase().search(searchRegEx);
          if (searchTerm.length > 0 && match >= 0) {
            d.searched = true;
            element.classed("background", false);
            meta += "<a class=\"node\" href=\"#\">" + d.name + "</a> ";
          } else {
            d.searched = false;
            element.classed("background", true);
          }
          element.classed('searched', d.searched);
          return link.classed("background", true);
        });
        meta += "</div>";
        return $('#meta .searchResults').html(meta);
      } else {
        $('#meta .searchResults').html("");
        node.classed('searched background', false);
        node.attr('searched', false);
        return link.classed('highlight background', false);
      }
    };
    showDetails = function(d, i) {
      var categories, connected, connectedData, incoming, nodeMeta, outgoing;
      if (d3.event.defaultPrevented) {
        return;
      }
      d3.event.stopPropagation();
      if (link) {
        link.classed("highlight", function(l) {
          if (l.source === d || l.target === d) {
            return true;
          } else {
            return false;
          }
        });
        link.classed("background", function(l) {
          if (l.source === d || l.target === d) {
            return false;
          } else {
            return true;
          }
        });
      }
      node.classed("highlight", function(n) {
        if (neighboring(d, n)[0] || neighboring(d, n)[1]) {
          return true;
        } else {
          return false;
        }
      });
      node.classed("background", function(n) {
        if (neighboring(d, n)[0] || neighboring(d, n)[1]) {
          return false;
        } else {
          return true;
        }
      });
      node.classed("selected", false);
      d3.select(this).classed({
        'highlight selected': true,
        'background': false
      });
      nodeMeta = d3.select("#meta .nodes");
      nodeMeta.text(null);
      nodeMeta.append("h2").text(d.name);
      categories = nodeMeta.append("div").attr("class", "categories");
      categories.selectAll("a").data(d.category).enter().append("a").attr("href", '#').attr("class", function(n) {
        return "category " + (n.toLowerCase());
      }).text(function(n) {
        return n;
      });
      connected = nodeMeta.append("div").attr("class", "connected");
      connectedData = curNodesData.filter(function(n) {
        return neighboring(d, n)[0] || neighboring(d, n)[1];
      });
      connected.append("h3").text("Beeinflusst..");
      outgoing = connected.append("div").attr("class", "outgoing").selectAll(".node").data(connectedData.filter(function(n) {
        return neighboring(d, n)[0];
      }), function(n) {
        return n.id;
      });
      outgoing.enter().append("div").attr("class", "node").text(function(n) {
        return "(" + linkWeight[d.id + "," + n.id] + ")";
      }).append("a").attr('href', '#').attr('title', function(n) {
        return ("Mehr " + d.name + " verursacht ") + (linkWeight[d.id + "," + n.id] < 0 ? "weniger" : "mehr") + (" " + n.name + ".");
      }).text(function(n) {
        return n.name;
      }).on('click', function(n) {
        return zoomToNode(n);
      });
      connected.append("h3").text("Wird beeinflusst von..");
      incoming = connected.append("div").attr("class", "incoming").selectAll(".node").data(connectedData.filter(function(n) {
        return neighboring(d, n)[1];
      }), function(n) {
        return n.id;
      });
      return incoming.enter().append("div").attr("class", "node").text(function(n) {
        return "(" + linkWeight[n.id + "," + d.id] + ")";
      }).append("a").attr('href', '#').attr('title', function(n) {
        return ("Mehr " + n.name + " verursacht ") + (linkWeight[n.id + "," + d.id] < 0 ? "weniger" : "mehr") + (" " + d.name + ".");
      }).text(function(n) {
        return n.name;
      }).on('click', function(n) {
        return zoomToNode(n);
      });
    };
    hideDetails = function(d, i) {
      if (d3.event.defaultPrevented) {
        return;
      }
      node.classed("highlight background selected searched", false);
      if (link) {
        link.classed("highlight background", false);
      }
      d3.select("#meta .nodes").text(null);
      $("#search").val("");
      d3.select('#meta .searchResults').text(null);
      return node.attr('searched', false);
    };
    neighboring = function(a, b) {
      return [linkedByIndex[a.id + "," + b.id], linkedByIndex[b.id + "," + a.id]];
    };
    setSize = function() {
      var svgStyles;
      svgStyles = window.getComputedStyle(vis.node());
      svgW = parseInt(svgStyles["width"]);
      svgH = parseInt(svgStyles["height"]);
      vis.attr("width", svgW).attr("height", svgH);
      xScale.range([0, svgW]);
      yScale.range([0, svgH]);
      zoom.x(xScale).y(yScale);
      if (debug) {
        console.log("resize", xScale.range(), yScale.range());
        console.log("x domain", xScale.domain(), "x range", xScale.range());
      }
      return forceTick();
    };
    window.addEventListener("resize", setSize, false);
    collide = function(alpha) {
      var quadtree;
      quadtree = d3.geom.quadtree(curNodesData);
      return function(d) {
        var nx1, nx2, ny1, ny2, rb;
        rb = 2 * d.radius + 10;
        nx1 = d.x - rb;
        nx2 = d.x + rb;
        ny1 = d.y - rb;
        ny2 = d.y + rb;
        return quadtree.visit(function(quad, x1, y1, x2, y2) {
          var l, x, y;
          if (quad.point && (quad.point !== d)) {
            x = d.x - quad.point.x;
            y = d.y - quad.point.y;
            l = Math.sqrt(x * x + y * y);
            if (l < rb) {
              l = (l - rb) / l * alpha;
              d.x -= x *= l;
              d.y -= y *= l;
              quad.point.x += x;
              quad.point.y += y;
            }
          }
          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        });
      };
    };
    zoomToNode = function(n) {
      var scale, translate;
      console.log("zoom to node! width:" + width + " svgW:" + svgW + " height:" + height);
      scale = 4;
      translate = [width / 2 - scale * n.x, height / 2 - scale * n.y];
      return vis.transition().duration(750).call(zoom.translate(translate).scale(scale).event);
    };
    network.reset = function() {
      return vis.transition().duration(750).call(zoom.translate([0, 0]).scale(1).event);
    };
    return network;
  };

  $(function() {
    var myNetwork;
    myNetwork = Network();
    $("#graph #search").keyup(function() {
      var searchTerm;
      searchTerm = $(this).val();
      return myNetwork.updateSearch(searchTerm);
    });
    $("#graph #reset").click(function() {
      return myNetwork.reset();
    });
    $('#graph #categories #filter').click(function() {
      var filter;
      filter = [];
      $('#graph #categories :checkbox:checked').each(function() {
        return filter.push($(this).val());
      });
      if (debug) {
        console.log("filter", filter);
      }
      return myNetwork.setFilter(filter);
    });
    $('#meta').tooltip({
      position: {
        my: "center bottom-10",
        at: "center top",
        collision: 'none',
        using: function(position, feedback) {
          $(this).css(position);
          return $("<div>").addClass("arrow").addClass(feedback.vertical).addClass(feedback.horizontal).appendTo(this);
        }
      },
      hide: false
    });
    return d3.json(PREFIX + "/data/graph.json", function(json) {
      return myNetwork("#bioGraph", json);
    });
  });

}).call(this);
