// Generated by CoffeeScript 1.7.1
(function() {
  var Network, PREFIX, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  PREFIX = "";

  Network = function() {
    var allData, color, curLinksData, curNodesData, filterLinks, filterNodes, force, forceTick, height, hideDetails, link, linkedByIndex, linksG, mapNodes, neighboring, network, node, nodesG, setupData, showDetails, tip, update, updateLinks, updateNodes, width;
    width = 700;
    height = 600;
    nodesG = null;
    linksG = null;
    node = null;
    link = null;
    allData = [];
    curLinksData = [];
    curNodesData = [];
    linkedByIndex = {};
    color = d3.scale.category20();
    tip = d3.tip().attr('class', 'd3-tip').html(function(d) {
      return d.name;
    }).direction('n').offset(function(d) {
      return [-(d.radius / 2 + 3), 0];
    });
    force = d3.layout.force().charge(-250).linkDistance(120).size([width, height]);
    network = function(selection, graph) {
      var vis;
      allData = setupData(graph);
      vis = d3.select(selection).append("svg").attr("width", width).attr("height", height);
      linksG = vis.append("g").attr("id", "links");
      nodesG = vis.append("g").attr("id", "nodes");
      vis.call(tip);
      force.on("tick", forceTick);
      return update();
    };
    update = function() {
      curNodesData = allData.nodes;
      curLinksData = allData.links;
      force.nodes(curNodesData);
      force.links(curLinksData);
      updateNodes();
      updateLinks();
      return force.start();
    };
    forceTick = function() {
      link.attr("x1", function(d) {
        return d.source.x;
      }).attr("y1", function(d) {
        return d.source.y;
      }).attr("x2", function(d) {
        return d.target.x;
      }).attr("y2", function(d) {
        return d.target.y;
      });
      return node.attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      });
    };
    updateNodes = function() {
      node = nodesG.selectAll("circle.node").data(curNodesData, function(d) {
        return d.id;
      });
      node.enter().append("circle").attr("class", "node").attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      }).attr("r", function(d) {
        return d.radius;
      }).style("fill", function(d) {
        return color(4);
      }).call(force.drag).on('mouseover', showDetails).on('mouseout', hideDetails);
      return node.exit().remove();
    };
    updateLinks = function() {
      link = linksG.selectAll("line.link").data(curLinksData, function(d) {
        return "" + d.source.id + "_" + d.target.id;
      });
      link.enter().append("line").attr("class", "link").attr("x1", function(d) {
        return d.source.x;
      }).attr("y1", function(d) {
        return d.source.y;
      }).attr("x2", function(d) {
        return d.target.x;
      }).attr("y2", function(d) {
        return d.target.y;
      });
      return link.exit().remove();
    };
    filterNodes = function(allNodes) {
      var cutoff, filteredNodes, playcounts;
      filteredNodes = allNodes;
      if (filter === "popular" || filter === "obscure") {
        playcounts = allNodes.map(function(d) {
          return d.playcount;
        }).sort(d3.ascending);
        cutoff = d3.quantile(playcounts, 0.5);
        filteredNodes = allNodes.filter(function(n) {
          if (filter === "popular") {
            return n.playcount > cutoff;
          } else if (filter === "obscure") {
            return n.playcount <= cutoff;
          }
        });
      }
      return filteredNodes;
    };
    filterLinks = function(allLinks, curNodes) {
      curNodes = mapNodes(curNodes);
      return allLinks.filter(function(l) {
        return curNodes.get(l.source.id) && curNodes.get(l.target.id);
      });
    };
    setupData = function(data) {
      var circleRadius, degreeExtent, nodesMap;
      degreeExtent = d3.extent(data.nodes, function(d) {
        return d.degree;
      });
      circleRadius = d3.scale.sqrt().range([5, 14]).domain(degreeExtent);
      data.nodes.forEach(function(n) {
        var randomnumber;
        n.x = randomnumber = Math.floor(Math.random() * width);
        n.y = randomnumber = Math.floor(Math.random() * height);
        return n.radius = circleRadius(n.degree);
      });
      nodesMap = mapNodes(data.nodes);
      data.links.forEach(function(l) {
        l.source = nodesMap.get(l.source);
        l.target = nodesMap.get(l.target);
        return linkedByIndex["" + l.source.id + "," + l.target.id] = 1;
      });
      return data;
    };
    mapNodes = function(nodes) {
      var nodesMap;
      nodesMap = d3.map();
      nodes.forEach(function(n) {
        return nodesMap.set(n.id, n);
      });
      return nodesMap;
    };
    showDetails = function(d, i) {
      tip.show(d);
      if (link) {
        link.classed("highlight", function(l) {
          if (l.source === d || l.target === d) {
            return true;
          } else {
            return false;
          }
        });
        link.classed("background", function(l) {
          if (l.source === d || l.target === d) {
            return false;
          } else {
            return true;
          }
        });
      }
      node.classed("highlight", function(n) {
        if (n.searched || neighboring(d, n)) {
          return true;
        } else {
          return false;
        }
      });
      node.classed("background", function(n) {
        if (n.searched || neighboring(d, n)) {
          return false;
        } else {
          return true;
        }
      });
      return d3.select(this).classed({
        'highlight': true,
        'background': false
      });
    };
    hideDetails = function(d, i) {
      tip.hide(d);
      node.classed("highlight", function(n) {
        if (!n.searched) {
          return false;
        } else {
          return true;
        }
      });
      node.classed("background", function(n) {
        if (!n.searched) {
          return false;
        } else {
          return true;
        }
      });
      if (link) {
        return link.classed("highlight background", false);
      }
    };
    neighboring = function(a, b) {
      return linkedByIndex[a.id + "," + b.id] || linkedByIndex[b.id + "," + a.id];
    };
    return network;
  };

  $(function() {
    var myNetwork;
    myNetwork = Network();
    return d3.json(PREFIX + "/data/graph.json", function(json) {
      return myNetwork("#bioGraph", json);
    });
  });

}).call(this);
